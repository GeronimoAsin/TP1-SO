<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/playerV2.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/playerV2.c" />
              <option name="originalContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#define MAX_PLAYERS 9&#10;&#10;typedef struct {&#10;    char playerName[16];&#10;    unsigned int score;&#10;    unsigned int invalid;&#10;    unsigned int valid;&#10;    unsigned short x, y;&#10;    pid_t pid;&#10;    bool blocked;&#10;} Player;&#10;&#10;typedef struct {&#10;    unsigned short width;&#10;    unsigned short height;&#10;    unsigned int playersNumber;&#10;    Player players[9];&#10;    bool gameOver;&#10;    int **rows;&#10;} GameState;&#10;&#10;typedef struct{&#10;    sem_t pendingView;&#10;    sem_t viewEndedPrinting;&#10;    sem_t mutexMasterAccess;     // turnstile for writer-preference&#10;    sem_t mutexGameState;        // resource (writers lock exclusively, first/last reader semantics)&#10;    sem_t mutexPlayerAccess;     // protects playersReadingState&#10;    unsigned int playersReadingState; // readers count&#10;    sem_t playerCanMove[9];&#10;} Semaphores;&#10;&#10;&#10;int main(int argc, char *argv[]) {&#10;    unsigned int width = atoi(argv[1]);&#10;    unsigned int height = atoi(argv[2]);&#10;    GameState *gameState = connectToSharedMemoryState(width, height);&#10;    Semaphores *semaphores = connectToSharedMemorySemaphores();&#10;&#10;    //Averiguamos a que indice del arreglo de semaforos corresponde este proceso&#10;    int playerIndex = -1;&#10;    for (int i = 0; i &lt; MAX_PLAYERS &amp;&amp; playerIndex == -1; i++) {&#10;        if (gameState-&gt;players[i].pid == getpid()) {&#10;            playerIndex = i;&#10;        }&#10;    }&#10;&#10;    //Lectura del GameState y escribo el movimiento que quiero hacer en el fd=1&#10;    //Luego de haber solicitado el movimiento se bloquea hasta que el master lo habilite de nuevo&#10;    //@TODO&#10;    while(!gameState-&gt;gameOver){&#10;        // Esperar a que el máster habilite este jugador &#10;        while (sem_wait(&amp;semaphores-&gt;playerCanMove[playerIndex]) == -1 &amp;&amp; errno == EINTR) {}&#10;&#10;        //semaforo C&#10;        //Valida que durante el bloqueo no se haya terminado el juego&#10;        if (gameState-&gt;gameOver) break;&#10;&#10;        // Reader-enter: pass through master's turnstile to avoid entering while a writer is waiting&#10;        while (sem_wait(&amp;semaphores-&gt;mutexMasterAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        while (sem_wait(&amp;semaphores-&gt;mutexPlayerAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        if (semaphores-&gt;playersReadingState++ == 0) {&#10;            while (sem_wait(&amp;semaphores-&gt;mutexGameState) == -1 &amp;&amp; errno == EINTR) {}&#10;        }&#10;        sem_post(&amp;semaphores-&gt;mutexPlayerAccess);&#10;        sem_post(&amp;semaphores-&gt;mutexMasterAccess);&#10;&#10;        // === Inicio de la sección de lectura del estado compartido ===&#10;        unsigned int currentX = gameState-&gt;players[playerIndex].x;&#10;        unsigned int currentY = gameState-&gt;players[playerIndex].y;&#10;        unsigned char movement = 9;&#10;        unsigned int max = 0;&#10;&#10;        // el &quot;&lt;&quot; no incluia la posicion +1 solo permitia moverse en -1 y 0&#10;        for(int i=-1; i&lt;=1; i++){&#10;            for(int j=-1; j&lt;=1; j++)&#10;            {&#10;                if((i != 0 || j != 0) &amp;&amp; currentX + i &lt; gameState-&gt;height &amp;&amp; currentY + j &lt; gameState-&gt;width &amp;&amp; (int)(currentX + i) &gt;= 0 &amp;&amp; (int)(currentY + j) &gt;= 0 &amp;&amp; gameState-&gt;rows[currentX + i][currentY + j])&#10;                {&#10;                    if(gameState-&gt;rows[currentX + i][currentY + j] &gt; max)&#10;                    {&#10;                        max = gameState-&gt;rows[currentX + i][currentY + j];&#10;                        if(i == -1 &amp;&amp; j == 0){&#10;                            movement = 6;&#10;                        } else if(i == 1 &amp;&amp; j == 0){&#10;                            movement = 2;&#10;                        } else if(i == 0 &amp;&amp; j == -1){&#10;                            movement = 0;&#10;                        } else if(i == 0 &amp;&amp; j == 1){&#10;                            movement = 4;&#10;                        }else if(i == -1 &amp;&amp; j == -1){&#10;                            movement = 7;&#10;                        } else if(i == -1 &amp;&amp; j == 1 ){&#10;                            movement = 5;&#10;                        } else if(i == 1 &amp;&amp; j == -1){&#10;                            movement = 1;&#10;                        } else if(i == 1 &amp;&amp; j == 1){&#10;                            movement = 3;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // === Fin de la sección de lectura ===&#10;&#10;        // Reader-exit&#10;        while (sem_wait(&amp;semaphores-&gt;mutexPlayerAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        if (--semaphores-&gt;playersReadingState == 0) {&#10;            sem_post(&amp;semaphores-&gt;mutexGameState);&#10;        }&#10;        sem_post(&amp;semaphores-&gt;mutexPlayerAccess);&#10;&#10;        // Enviar el movimiento elegido&#10;        write(1, &amp;movement, sizeof(movement));&#10;    }&#10;    return 0;&#10;}&#10;&#10;GameState * connectToSharedMemoryState(unsigned int width, unsigned int height) {&#10;    int gameStateSmFd = shm_open(&quot;/game_state&quot;, O_RDWR, 0666);&#10;    if (gameStateSmFd == -1) {&#10;        perror(&quot;Error al abrir la memoria compartida para el estado del juego&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    GameState *gameState = mmap(NULL, sizeof(GameState) + (sizeof(int *) * height * width * sizeof(int)), PROT_READ , MAP_SHARED, gameStateSmFd, 0);&#10;    if (gameState == MAP_FAILED) {&#10;        perror(&quot;Error al mapear la memoria compartida&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    return gameState;&#10;}&#10;&#10;Semaphores * connectToSharedMemorySemaphores() {&#10;    int semaphoresSmFd = shm_open(&quot;/game_sync&quot;, O_RDWR, 0666);&#10;    if (semaphoresSmFd == -1) {&#10;        perror(&quot;Error al abrir la memoria compartida para los semáforos&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    Semaphores *semaphores = mmap(NULL, sizeof(Semaphores), PROT_READ | PROT_WRITE, MAP_SHARED, semaphoresSmFd, 0);&#10;    if (semaphores == MAP_FAILED) {&#10;        perror(&quot;Error al mapear la memoria compartida&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    return semaphores;&#10;}" />
              <option name="updatedContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#define MAX_PLAYERS 9&#10;&#10;typedef struct {&#10;    char playerName[16];&#10;    unsigned int score;&#10;    unsigned int invalid;&#10;    unsigned int valid;&#10;    unsigned short x, y;&#10;    pid_t pid;&#10;    bool blocked;&#10;} Player;&#10;&#10;typedef struct {&#10;    unsigned short width;&#10;    unsigned short height;&#10;    unsigned int playersNumber;&#10;    Player players[9];&#10;    bool gameOver;&#10;    int **rows;&#10;} GameState;&#10;&#10;typedef struct{&#10;    sem_t pendingView;&#10;    sem_t viewEndedPrinting;&#10;    sem_t mutexMasterAccess;     // turnstile for writer-preference&#10;    sem_t mutexGameState;        // resource (writers lock exclusively, first/last reader semantics)&#10;    sem_t mutexPlayerAccess;     // protects playersReadingState&#10;    unsigned int playersReadingState; // readers count&#10;    sem_t playerCanMove[9];&#10;} Semaphores;&#10;&#10;&#10;int main(int argc, char *argv[]) {&#10;    unsigned int width = atoi(argv[1]);&#10;    unsigned int height = atoi(argv[2]);&#10;    GameState *gameState = connectToSharedMemoryState(width, height);&#10;    Semaphores *semaphores = connectToSharedMemorySemaphores();&#10;&#10;    //Averiguamos a que indice del arreglo de semaforos corresponde este proceso&#10;    int playerIndex = -1;&#10;    for (int i = 0; i &lt; MAX_PLAYERS &amp;&amp; playerIndex == -1; i++) {&#10;        if (gameState-&gt;players[i].pid == getpid()) {&#10;            playerIndex = i;&#10;        }&#10;        if (playerIndex == -1) usleep(1000);&#10;    }&#10;&#10;    //Lectura del GameState y escribo el movimiento que quiero hacer en el fd=1&#10;    //Luego de haber solicitado el movimiento se bloquea hasta que el master lo habilite de nuevo&#10;    //@TODO&#10;    while(!gameState-&gt;gameOver){&#10;        // Esperar a que el máster habilite este jugador &#10;        while (sem_wait(&amp;semaphores-&gt;playerCanMove[playerIndex]) == -1 &amp;&amp; errno == EINTR) {}&#10;&#10;        //semaforo C&#10;        //Valida que durante el bloqueo no se haya terminado el juego&#10;        if (gameState-&gt;gameOver) break;&#10;&#10;        // Reader-enter: pass through master's turnstile to avoid entering while a writer is waiting&#10;        while (sem_wait(&amp;semaphores-&gt;mutexMasterAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        while (sem_wait(&amp;semaphores-&gt;mutexPlayerAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        if (semaphores-&gt;playersReadingState++ == 0) {&#10;            while (sem_wait(&amp;semaphores-&gt;mutexGameState) == -1 &amp;&amp; errno == EINTR) {}&#10;        }&#10;        sem_post(&amp;semaphores-&gt;mutexPlayerAccess);&#10;        sem_post(&amp;semaphores-&gt;mutexMasterAccess);&#10;&#10;        // === Inicio de la sección de lectura del estado compartido ===&#10;        unsigned int currentX = gameState-&gt;players[playerIndex].x;&#10;        unsigned int currentY = gameState-&gt;players[playerIndex].y;&#10;        unsigned char movement = 9;&#10;        unsigned int max = 0;&#10;&#10;        // el &quot;&lt;&quot; no incluia la posicion +1 solo permitia moverse en -1 y 0&#10;        for(int i=-1; i&lt;=1; i++){&#10;            for(int j=-1; j&lt;=1; j++)&#10;            {&#10;                if((i != 0 || j != 0) &amp;&amp; currentX + i &lt; gameState-&gt;height &amp;&amp; currentY + j &lt; gameState-&gt;width &amp;&amp; (int)(currentX + i) &gt;= 0 &amp;&amp; (int)(currentY + j) &gt;= 0 &amp;&amp; gameState-&gt;rows[currentX + i][currentY + j])&#10;                {&#10;                    if(gameState-&gt;rows[currentX + i][currentY + j] &gt; max)&#10;                    {&#10;                        max = gameState-&gt;rows[currentX + i][currentY + j];&#10;                        if(i == -1 &amp;&amp; j == 0){&#10;                            movement = 6;&#10;                        } else if(i == 1 &amp;&amp; j == 0){&#10;                            movement = 2;&#10;                        } else if(i == 0 &amp;&amp; j == -1){&#10;                            movement = 0;&#10;                        } else if(i == 0 &amp;&amp; j == 1){&#10;                            movement = 4;&#10;                        }else if(i == -1 &amp;&amp; j == -1){&#10;                            movement = 7;&#10;                        } else if(i == -1 &amp;&amp; j == 1 ){&#10;                            movement = 5;&#10;                        } else if(i == 1 &amp;&amp; j == -1){&#10;                            movement = 1;&#10;                        } else if(i == 1 &amp;&amp; j == 1){&#10;                            movement = 3;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        // === Fin de la sección de lectura ===&#10;&#10;        // Reader-exit&#10;        while (sem_wait(&amp;semaphores-&gt;mutexPlayerAccess) == -1 &amp;&amp; errno == EINTR) {}&#10;        if (--semaphores-&gt;playersReadingState == 0) {&#10;            sem_post(&amp;semaphores-&gt;mutexGameState);&#10;        }&#10;        sem_post(&amp;semaphores-&gt;mutexPlayerAccess);&#10;&#10;        // Enviar el movimiento elegido&#10;        write(1, &amp;movement, sizeof(movement));&#10;    }&#10;    return 0;&#10;}&#10;&#10;GameState * connectToSharedMemoryState(unsigned int width, unsigned int height) {&#10;    int gameStateSmFd = shm_open(&quot;/game_state&quot;, O_RDWR, 0666);&#10;    if (gameStateSmFd == -1) {&#10;        perror(&quot;Error al abrir la memoria compartida para el estado del juego&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    GameState *gameState = mmap(NULL, sizeof(GameState) + (sizeof(int *) * height * width * sizeof(int)), PROT_READ , MAP_SHARED, gameStateSmFd, 0);&#10;    if (gameState == MAP_FAILED) {&#10;        perror(&quot;Error al mapear la memoria compartida&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    return gameState;&#10;}&#10;&#10;Semaphores * connectToSharedMemorySemaphores() {&#10;    int semaphoresSmFd = shm_open(&quot;/game_sync&quot;, O_RDWR, 0666);&#10;    if (semaphoresSmFd == -1) {&#10;        perror(&quot;Error al abrir la memoria compartida para los semáforos&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    Semaphores *semaphores = mmap(NULL, sizeof(Semaphores), PROT_READ | PROT_WRITE, MAP_SHARED, semaphoresSmFd, 0);&#10;    if (semaphores == MAP_FAILED) {&#10;        perror(&quot;Error al mapear la memoria compartida&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    return semaphores;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>