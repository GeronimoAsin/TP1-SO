<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/estructuras.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/estructuras.h" />
              <option name="originalContent" value="#ifndef ESTRUCTURAS_H_&#10;#define ESTRUCTURAS_H_&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;stddef.h&gt;&#10;#include &lt;errno.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#define MAX_PLAYERS 9&#10;&#10;typedef struct&#10;{&#10;    char playerName[16];&#10;    unsigned int score;&#10;    unsigned int invalid;&#10;    unsigned int valid;&#10;    unsigned short x, y;&#10;    pid_t pid;&#10;    bool blocked;&#10;} Player;&#10;&#10;typedef struct&#10;{&#10;    unsigned short width;&#10;    unsigned short height;&#10;    unsigned int playersNumber;&#10;    Player players[9];&#10;    bool gameOver;&#10;    int grid[]; // grilla almacenada en memoria compartida en formato arreglo width*height&#10;} GameState;&#10;&#10;typedef struct&#10;{&#10;    sem_t pendingView;&#10;    sem_t viewEndedPrinting;&#10;    sem_t mutexMasterAccess;&#10;    sem_t mutexGameState;&#10;    sem_t mutexPlayerAccess;&#10;    unsigned int playersReadingState;&#10;    sem_t playerCanMove[9];&#10;} Semaphores;&#10;&#10;&#10;static inline GameState * connectToSharedMemoryState(unsigned int width, unsigned int height) {&#10;    int gameStateSmFd = shm_open(&quot;/game_state&quot;, O_RDONLY, 0666);&#10;    if (gameStateSmFd == -1) {&#10;        fprintf(stderr, &quot;Error al abrir la memoria compartida para el estado del juego: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        exit(1);&#10;    }&#10;&#10;    size_t map_size = sizeof(GameState) + (size_t)width * height * sizeof(int);&#10;&#10;    GameState *gameState = mmap(NULL, map_size, PROT_READ , MAP_SHARED, gameStateSmFd, 0);&#10;    if (gameState == MAP_FAILED) {&#10;        fprintf(stderr, &quot;Error al mapear la memoria compartida: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        close(gameStateSmFd);&#10;        exit(1);&#10;    }&#10;&#10;    // cerrar fd solo si no es 0/1/2&#10;    if (gameStateSmFd &gt; STDERR_FILENO) close(gameStateSmFd);&#10;&#10;    return gameState;&#10;}&#10;&#10;static inline Semaphores * connectToSharedMemorySemaphores(void) {&#10;    int semaphoresSmFd = shm_open(&quot;/game_sync&quot;, O_RDWR, 0666);&#10;    if (semaphoresSmFd == -1) {&#10;        fprintf(stderr, &quot;Error al abrir la memoria compartida para los semáforos: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        exit(1);&#10;    }&#10;&#10;    Semaphores *semaphores = mmap(NULL, sizeof(Semaphores), PROT_READ | PROT_WRITE, MAP_SHARED, semaphoresSmFd, 0);&#10;    if (semaphores == MAP_FAILED) {&#10;        fprintf(stderr, &quot;Error al mapear la memoria compartida de semáforos: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        if (semaphoresSmFd &gt; STDERR_FILENO) close(semaphoresSmFd);&#10;        exit(1);&#10;    }&#10;&#10;    // cerrar fd solo si no es 0/1/2&#10;    if (semaphoresSmFd &gt; STDERR_FILENO) close(semaphoresSmFd);&#10;&#10;    return semaphores;&#10;}&#10;&#10;&#10;&#10;#endif&#10;" />
              <option name="updatedContent" value="#ifndef ESTRUCTURAS_H_&#10;#define ESTRUCTURAS_H_&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;stddef.h&gt;&#10;#include &lt;errno.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#define MAX_PLAYERS 9&#10;&#10;typedef struct&#10;{&#10;    char playerName[16];&#10;    unsigned int score;&#10;    unsigned int invalid;&#10;    unsigned int valid;&#10;    unsigned short x, y;&#10;    pid_t pid;&#10;    bool blocked;&#10;} Player;&#10;&#10;typedef struct&#10;{&#10;    unsigned short width;&#10;    unsigned short height;&#10;    unsigned int playersNumber;&#10;    Player players[9];&#10;    bool gameOver;&#10;    int grid[]; // grilla almacenada en memoria compartida en formato arreglo width*height&#10;} GameState;&#10;&#10;typedef struct&#10;{&#10;    sem_t pendingView;&#10;    sem_t viewEndedPrinting;&#10;    sem_t mutexMasterAccess;&#10;    sem_t mutexGameState;&#10;    sem_t mutexPlayerAccess;&#10;    unsigned int playersReadingState;&#10;    sem_t playerCanMove[9];&#10;} Semaphores;&#10;&#10;&#10;static inline GameState * connectToSharedMemoryState(unsigned int width, unsigned int height) {&#10;    int gameStateSmFd = shm_open(&quot;/game_state&quot;, O_RDONLY, 0666);&#10;    if (gameStateSmFd == -1) {&#10;        fprintf(stderr, &quot;Error al abrir la memoria compartida para el estado del juego: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        exit(1);&#10;    }&#10;&#10;    size_t map_size = sizeof(GameState) + (size_t)width * height * sizeof(int);&#10;&#10;    GameState *gameState = mmap(NULL, map_size, PROT_READ , MAP_SHARED, gameStateSmFd, 0);&#10;    if (gameState == MAP_FAILED) {&#10;        fprintf(stderr, &quot;Error al mapear la memoria compartida: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        close(gameStateSmFd);&#10;        exit(1);&#10;    }&#10;&#10;    // cerrar fd solo si no es 0/1/2&#10;    if (gameStateSmFd &gt; STDERR_FILENO) close(gameStateSmFd);&#10;&#10;    return gameState;&#10;}&#10;&#10;static inline Semaphores * connectToSharedMemorySemaphores(void) {&#10;    int semaphoresSmFd = shm_open(&quot;/game_sync&quot;, O_RDWR, 0666);&#10;    if (semaphoresSmFd == -1) {&#10;        fprintf(stderr, &quot;Error al abrir la memoria compartida para los semáforos: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        exit(1);&#10;    }&#10;&#10;    Semaphores *semaphores = mmap(NULL, sizeof(Semaphores), PROT_READ | PROT_WRITE, MAP_SHARED, semaphoresSmFd, 0);&#10;    if (semaphores == MAP_FAILED) {&#10;        fprintf(stderr, &quot;Error al mapear la memoria compartida de semáforos: errno=%d (%s)\n&quot;, errno, strerror(errno));&#10;        if (semaphoresSmFd &gt; STDERR_FILENO) close(semaphoresSmFd);&#10;        exit(1);&#10;    }&#10;&#10;    // cerrar fd solo si no es 0/1/2&#10;    if (semaphoresSmFd &gt; STDERR_FILENO) close(semaphoresSmFd);&#10;&#10;    return semaphores;&#10;}&#10;&#10;&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/player.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/player.c" />
              <option name="originalContent" value="#include &quot;estructuras.h&quot;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#define MAX_PLAYERS 9&#10;&#10;// Forward declarations for reader lock helpers&#10;static inline void acquireGameStateReaderLock(Semaphores *semaphore);&#10;static inline void releaseGameStateReaderLock(Semaphores *semaphore);&#10;&#10;&#10;int main(int argc, char *argv[]) {&#10;&#10;  if (argc &lt; 3) {&#10;        fprintf(stderr, &quot;Uso: %s &lt;width&gt; &lt;height&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;&#10;    // Dimensiones para calcular el tamaño del mapeo de memoria.&#10;    unsigned int width = (unsigned int)atoi(argv[1]);&#10;    unsigned int height = (unsigned int)atoi(argv[2]);&#10;&#10;    GameState *gameState = connectToSharedMemoryState(width, height);&#10;    Semaphores *semaphores = connectToSharedMemorySemaphores();&#10;&#10;    //Determinación del indice del arreglo de semaforos correspondiente al jugador actual&#10;    int playerIndex = -1;&#10;    for (int i = 0; i &lt; MAX_PLAYERS &amp;&amp; playerIndex == -1; i++) {&#10;        if (gameState-&gt;players[i].pid == getpid()) {&#10;            playerIndex = i;&#10;        }&#10;    }&#10;    if (playerIndex == -1) {&#10;        fprintf(stderr, &quot;No se encontró el índice del jugador para el PID actual\n&quot;);&#10;        return 1;&#10;    }&#10;&#10;    bool isOver = false;&#10;&#10;&#10;&#10;    while(!isOver){&#10;&#10;        // Espera a que el máster habilite este jugador&#10;        while (sem_wait(&amp;semaphores-&gt;playerCanMove[playerIndex]) == -1 &amp;&amp; errno == EINTR) {}&#10;&#10;        // Adquirir lock de lectura del estado de juego (espera a que master no esté escribiendo y entra como lector)&#10;        acquireGameStateReaderLock(semaphores);&#10;&#10;        int currentX = (int)gameState-&gt;players[playerIndex].x; // columnas&#10;        int currentY = (int)gameState-&gt;players[playerIndex].y; // filas&#10;&#10;&#10;        unsigned int W = gameState-&gt;width;&#10;        unsigned int H = gameState-&gt;height;&#10;        unsigned char movement = 9; &#10;        int bestVal = -1;&#10;        &#10;&#10;        for(int dy=-1; dy&lt;=1; dy++){&#10;            for(int dx=-1; dx&lt;=1; dx++){&#10;                &#10;                if(dx == 0 &amp;&amp; dy == 0) &#10;                continue; // ignorar la celda actual&#10;                &#10;                int neighborX = currentX + dx;&#10;                int neighborY = currentY + dy;&#10;                &#10;                if (neighborX &gt;= 0 &amp;&amp; neighborX &lt; (int)W &amp;&amp; neighborY &gt;= 0 &amp;&amp; neighborY &lt; (int)H) &#10;                {&#10;                    int val = gameState-&gt;grid[neighborY * W + neighborX];&#10;                    &#10;                    if(val &gt; bestVal){&#10;                        bestVal = val;&#10;                        // Mapeo (dx,dy) -&gt; movimiento correspondiente&#10;                        if(dx == 0 &amp;&amp; dy == -1){ movement = 0; }           // arriba&#10;                        else if(dx == 1 &amp;&amp; dy == -1){ movement = 1; }      // arriba-derecha&#10;                        else if(dx == 1 &amp;&amp; dy == 0){ movement = 2; }       // derecha&#10;                        else if(dx == 1 &amp;&amp; dy == 1){ movement = 3; }       // abajo-derecha&#10;                        else if(dx == 0 &amp;&amp; dy == 1){ movement = 4; }       // abajo&#10;                        else if(dx == -1 &amp;&amp; dy == 1){ movement = 5; }      // abajo-izquierda&#10;                        else if(dx == -1 &amp;&amp; dy == 0){ movement = 6; }      // izquierda&#10;                        else if(dx == -1 &amp;&amp; dy == -1){ movement = 7; }     // arriba-izquierda&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Liberar lock de lectura del estado de juego&#10;        releaseGameStateReaderLock(semaphores);&#10;&#10;        // Validación fin de juego&#10;        if (gameState-&gt;gameOver){&#10;            isOver = true;&#10;        }&#10;&#10;&#10;        // Enviar movimiento al master&#10;        write(1, &amp;movement, sizeof(movement));&#10;&#10;    }&#10;    return 0;&#10;}&#10;&#10;static inline void acquireGameStateReaderLock(Semaphores *semaphore)&#10;{&#10;    // Mecanismo Readers-Writers (entrada de lector)&#10;    sem_wait(&amp;semaphore-&gt;mutexMasterAccess);  // Toma prioridad como &quot;writer&quot;&#10;    sem_post(&amp;semaphore-&gt;mutexMasterAccess);  // Libera el control del master inmediatamente&#10;&#10;    sem_wait(&amp;semaphore-&gt;mutexPlayerAccess);&#10;    if (semaphore-&gt;playersReadingState++ == 0) {&#10;        sem_wait(&amp;semaphore-&gt;mutexGameState); // el primer lector toma el mutex&#10;    }&#10;    sem_post(&amp;semaphore-&gt;mutexPlayerAccess);&#10;}&#10;&#10;static inline void releaseGameStateReaderLock(Semaphores *semaphore)&#10;{&#10;    // Mecanismo Readers-Writers (salida de lector)&#10;    sem_wait(&amp;semaphore-&gt;mutexPlayerAccess);&#10;    if (--semaphore-&gt;playersReadingState == 0) {&#10;        sem_post(&amp;semaphore-&gt;mutexGameState); // el último lector en salir libera el mutex&#10;    }&#10;    sem_post(&amp;semaphore-&gt;mutexPlayerAccess);&#10;}" />
              <option name="updatedContent" value="#include &quot;estructuras.h&quot;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;sys/mman.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#define MAX_PLAYERS 9&#10;&#10;// Forward declarations for reader lock helpers&#10;static inline void acquireGameStateReaderLock(Semaphores *semaphore);&#10;static inline void releaseGameStateReaderLock(Semaphores *semaphore);&#10;&#10;&#10;int main(int argc, char *argv[]) {&#10;&#10;  if (argc &lt; 3) {&#10;        fprintf(stderr, &quot;Uso: %s &lt;width&gt; &lt;height&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;&#10;    // Dimensiones para calcular el tamaño del mapeo de memoria.&#10;    unsigned int width = (unsigned int)atoi(argv[1]);&#10;    unsigned int height = (unsigned int)atoi(argv[2]);&#10;&#10;    GameState *gameState = connectToSharedMemoryState(width, height);&#10;    Semaphores *semaphores = connectToSharedMemorySemaphores();&#10;&#10;    //Determinación del indice del arreglo de semaforos correspondiente al jugador actual&#10;    int playerIndex = -1;&#10;    for (int i = 0; i &lt; MAX_PLAYERS &amp;&amp; playerIndex == -1; i++) {&#10;        if (gameState-&gt;players[i].pid == getpid()) {&#10;            playerIndex = i;&#10;        }&#10;    }&#10;    if (playerIndex == -1) {&#10;        fprintf(stderr, &quot;No se encontró el índice del jugador para el PID actual\n&quot;);&#10;        return 1;&#10;    }&#10;&#10;    bool isOver = false;&#10;&#10;&#10;&#10;    while(!isOver){&#10;&#10;        // Espera a que el máster habilite este jugador&#10;        while (sem_wait(&amp;semaphores-&gt;playerCanMove[playerIndex]) == -1 &amp;&amp; errno == EINTR) {}&#10;&#10;        // Adquirir lock de lectura del estado de juego (espera a que master no esté escribiendo y entra como lector)&#10;        acquireGameStateReaderLock(semaphores);&#10;&#10;        int currentX = (int)gameState-&gt;players[playerIndex].x; // columnas&#10;        int currentY = (int)gameState-&gt;players[playerIndex].y; // filas&#10;&#10;&#10;        unsigned int W = gameState-&gt;width;&#10;        unsigned int H = gameState-&gt;height;&#10;        unsigned char movement = 9; &#10;        int bestVal = -1;&#10;        &#10;&#10;        for(int dy=-1; dy&lt;=1; dy++){&#10;            for(int dx=-1; dx&lt;=1; dx++){&#10;                &#10;                if(dx == 0 &amp;&amp; dy == 0) &#10;                continue; // ignorar la celda actual&#10;                &#10;                int neighborX = currentX + dx;&#10;                int neighborY = currentY + dy;&#10;                &#10;                if (neighborX &gt;= 0 &amp;&amp; neighborX &lt; (int)W &amp;&amp; neighborY &gt;= 0 &amp;&amp; neighborY &lt; (int)H) &#10;                {&#10;                    int val = gameState-&gt;grid[neighborY * W + neighborX];&#10;                    &#10;                    if(val &gt; bestVal){&#10;                        bestVal = val;&#10;                        // Mapeo (dx,dy) -&gt; movimiento correspondiente&#10;                        if(dx == 0 &amp;&amp; dy == -1){ movement = 0; }           // arriba&#10;                        else if(dx == 1 &amp;&amp; dy == -1){ movement = 1; }      // arriba-derecha&#10;                        else if(dx == 1 &amp;&amp; dy == 0){ movement = 2; }       // derecha&#10;                        else if(dx == 1 &amp;&amp; dy == 1){ movement = 3; }       // abajo-derecha&#10;                        else if(dx == 0 &amp;&amp; dy == 1){ movement = 4; }       // abajo&#10;                        else if(dx == -1 &amp;&amp; dy == 1){ movement = 5; }      // abajo-izquierda&#10;                        else if(dx == -1 &amp;&amp; dy == 0){ movement = 6; }      // izquierda&#10;                        else if(dx == -1 &amp;&amp; dy == -1){ movement = 7; }     // arriba-izquierda&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Liberar lock de lectura del estado de juego&#10;        releaseGameStateReaderLock(semaphores);&#10;&#10;        // Validación fin de juego&#10;        if (gameState-&gt;gameOver){&#10;            isOver = true;&#10;        }&#10;&#10;&#10;        // Enviar movimiento al master&#10;        write(1, &amp;movement, sizeof(movement));&#10;&#10;    }&#10;    return 0;&#10;}&#10;&#10;static inline void acquireGameStateReaderLock(Semaphores *semaphore)&#10;{&#10;    // Mecanismo Readers-Writers (entrada de lector)&#10;    sem_wait(&amp;semaphore-&gt;mutexMasterAccess);  // Toma prioridad como &quot;writer&quot;&#10;    sem_post(&amp;semaphore-&gt;mutexMasterAccess);  // Libera el control del master inmediatamente&#10;&#10;    sem_wait(&amp;semaphore-&gt;mutexPlayerAccess);&#10;    if (semaphore-&gt;playersReadingState++ == 0) {&#10;        sem_wait(&amp;semaphore-&gt;mutexGameState); // el primer lector toma el mutex&#10;    }&#10;    sem_post(&amp;semaphore-&gt;mutexPlayerAccess);&#10;}&#10;&#10;static inline void releaseGameStateReaderLock(Semaphores *semaphore)&#10;{&#10;    // Mecanismo Readers-Writers (salida de lector)&#10;    sem_wait(&amp;semaphore-&gt;mutexPlayerAccess);&#10;    if (--semaphore-&gt;playersReadingState == 0) {&#10;        sem_post(&amp;semaphore-&gt;mutexGameState); // el último lector en salir libera el mutex&#10;    }&#10;    sem_post(&amp;semaphore-&gt;mutexPlayerAccess);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>